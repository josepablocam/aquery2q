Capacity planning

utilization = arrival rate * service time.
Average work per second as a fraction.
e.g. arrival rate = 10/sec; service time = 1/20 sec
then utilization would be 1/2.

If perfectly uniform flow, then utilization less than one
would ensure zero wait time.
But poisson arrivals are not perfectly uniform.

After hitting a state, a user performs some action and then thinks.
If the think time statistics do not vary over the course of 
a day and provided think time is longer than search time, then 
this simple algebraic calculation of arrival rate works well.
For example, if there is a fixed d second delay, then 
a certain portion of the arrivals
from second t1 at state s  will  hit the next state s' at t1+d.
The same portion of arrivals at t1+1 at state s will hit s' at t1+d+1 etc.
The calculation is more complicated if think time is less than a second.


Chapter 14: 

foreign key join: R.A = S.B where S.B is a foreign
key of R.A.
Example: author(name, address) -- key is name; 
book(bookname, authorname) -- key is bookname, authorname
author.name would be a foreign key of book.authorname
So a foreign key join would be
book.authorname = author.name

When might it be bad to push the select below the join?
1. You can't because the selection is on multiple tables.
2. Selection on a single table, but using it will produce a result
that has no indexes. If the selection is not very selective (meaning
the result is nearly as big as the original table), then it's 
not worth it to lose the index.

bond(bondid, interest rate, maturity, company name....)
-- key is bondid

bondprice(bondid, date, price)

select bondprice.price, bondprice.date, bondprice.bondid
from bond, bondprice
where bond.interestrate = :x 
and bond.bondid = bondprice.bondid

Query optimizer says to itself "Hmm. Most interest rates have few
or no bonds associated with them, so a selection on interestrate
is very selective."

Suppose you have an index on bond.bondid

Look at the query plan: perform the selection on interestrate
and then do the join.

It is a fact from the application that most queries asked about
interest rates near the most frequent interest rate.
Selection on interestrate turns out to be very unselective.
As a result, it is bad to do the selection first.
Far better to use the index on bond.bondid and get the join
fast. Do the selection afterwards.

Estimate the number of rows resulting from a selection: 
Suppose I have n rows to begin with and I'm doing an equality
selection on some attribute A, then I might take the 
number of distinct A values, call that Anum and estimate
resulting size as n/Anum.

Estimating join sizes is easy for foreign key joins.
In the case:
select * from book, author where 
book.authorname = author.name

The result is equal to the size of book, because the join is foreign key.
If not foreign key but author.name is a key of author, then 
result is the size of book or possibly smaller.

Example (very rare) of non-foreign key join: 
I have a table 
phonenumber(landlinenumber, name, address) -- key is landline number
another table
cellphonenumber(cellnumber, name, address) -- key is cellnumber

I'd like to join on name.
That is key of neither table, so the result could be bigger
than the size of either table.
Comes up in data cleaning.

Otherwise, consult p. 14.38.



Join order example:

R(A,B), S(A,C), T(A,D)

Compute where clause:
R.A = S.A and S.A = T.A

if R and S are very big and T is small and all we have is merge join
and ability to build indexes, then it is probably better
to build an index on T.A and then 
to process the query
R.A = T.A and S.A = T.A run this through an index on T.

Time proportional to |T| log(T) + |R| log(T) + |S| log(T) 

On the other hand, if we construct an index on say R, we get

|R| log(R) + |S| log(R) + |T| log(R).

Bigger because of the logs.

How to do both joins against the T index.
Imagine (better data structures may be possible):
that we have a linked list off of each T.A value and we collect
the R and S rows that are equal to that value.
