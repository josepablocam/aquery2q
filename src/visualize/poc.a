// Moving variance calculation for technology stocks
CREATE TABLE prices (
  Open          FLOAT,
  High          FLOAT,
  Low           FLOAT,
  Close         FLOAT,
  Volume        FLOAT,
  EndOfDayPrice FLOAT,
  ID            STRING,
  Date          DATE
)

LOAD DATA INFILE "./data/sp500_eod_complete_data.csv" INTO TABLE prices
FIELDS TERMINATED BY  ","

<q>vars:{mavg[x;y*y]-m*m:mavg[x;y:"f"$y]}</q>
// moving variance for technology stocks
WITH
  variances(Date, ID, mv) AS (
    SELECT Date, ID,
      vars(12, ratios(1, EndOfDayPrice) - 1)
      FROM prices
      ASSUMING ASC Date
      WHERE ID in ("HP", "ORCL", "YHOO")
      AND Date >= '01/01/2015'
      GROUP BY ID
  )

SELECT * FROM FLATTEN(variances)


// Correlation of returns calculation for data
<q>
\S 1
corrTickers10:neg[10]?exec distinct ID from prices
</q>

WITH
  stocksGrouped(ID, Ret) AS (
    SELECT ID, ratios(1, EndOfDayPrice) - 1
    FROM prices
    ASSUMING ASC ID, ASC Date
    WHERE ID in corrTickers10 AND
    Date >= max(Date) - 31 * 6
    GROUP BY ID)

  pairsGrouped(ID1, ID2, R1, R2) AS (
    SELECT st1.ID, st2.ID, 
    st1.Ret, st2.Ret
    FROM stocksGrouped st1, stocksGrouped st2)
  
SELECT ID1, ID2,
cor(R1, R2) as coef 
FROM FLATTEN(pairsGrouped)
WHERE ID1 != ID2
GROUP BY ID1, ID2


// Moving Average Query for a specific stock
WITH
  mavgPrices(Date, Price, m21, m5) AS (
    SELECT 
    Date, 
    EndOfDayPrice,
    avgs(21,  EndOfDayPrice),
    avgs(5,  EndOfDayPrice)
    FROM prices
    ASSUMING ASC Date
    WHERE ID="HP"
    AND Date >= '01/01/2014')

// some simple if-else clauses to generate points
// for plotting signals
SELECT Date, Price,
m21, m5, 
CASE (prev(m5) <= prev(m21) & m5 > m21) 
 WHEN TRUE THEN
   Price
 ELSE make_null(Price)
 END as BuySignal,
CASE (prev(m5) >= prev(m21) & m5 < m21) 
WHEN TRUE THEN
  Price
ELSE make_null(Price) 
END as SellSignal
FROM mavgPrices


// Running maximum profit query
WITH
  runningProfit(Date, Price, RunningMinPrice, Profit) AS (
    SELECT Date, 
    EndOfDayPrice,
    mins(EndOfDayPrice), 
    EndOfDayPrice - mins(EndOfDayPrice)
    FROM prices
    ASSUMING ASC Date
    WHERE ID = "ORCL"
    AND Date >= '01/01/2015')
  
  markedUp(Date, Price, BestBuyPrice, BestSellPrice, Profit) AS (
    SELECT 
    Date,
    Price,
    CASE 
      WHEN Profit = max(Profit)
        THEN
          RunningMinPrice
        ELSE
          make_null(RunningMinPrice)
    END as BestBuyPrice,
    CASE 
      WHEN Profit = max(Profit)
        THEN
          Price
        ELSE
          make_null(Price)
    END as BestSellPrice,
    Profit
    FROM runningProfit)
    
  SELECT
  Date,
  Price,
  CASE
    WHEN Price = max(BestBuyPrice)
      THEN
        Price
      ELSE
        make_null(Price)
  END as BestBuyPrice,
  BestSellPrice,
  Profit
  FROM markedUp
      


/************************
 TRADING STRATEGIES
 ************************/
 
 /*
   Buy cheap strategy:
   Parameters: startDate, returns threshold, holding period (in business days), amount
   of money available for each investment date
   Investment "loop" (every trading day):
      - find set of stocks S with period returns < threshold (underperformers)
      if S not empty:
        - invest amount uniformly amongst them (we have access to M at each opportunity)
        - at end of y days, sell entire position (we always clear out, ie. each investment
        date is a "new portfolio")
   Display profit/loss associated with each investment date (when bought)
 */
 
 // We can encode query parameters as functions
 FUNCTION amt() {
   100000
 }

 FUNCTION startDate() {
   '01/01/2014'
 }

 FUNCTION returns_threshold() {
   -0.02
 }

 FUNCTION holding_period() {
   200
 }


WITH
  // calculate returns over period and sell price by shifting back future prices
  returns(Date, ID, BuyPrice, SellPrice, Ret) AS (
    SELECT Date, ID, EndOfDayPrice, 
    next(holding_period(), EndOfDayPrice), ratios(holding_period(), EndOfDayPrice)-1
    FROM prices ASSUMING ASC Date 
    GROUP BY ID
  )
  // select those underperformers that we are interested in
  purchases(Date, ID, BuyPrice, SellPrice, Ret) AS (
    SELECT * FROM FLATTEN(returns) WHERE Ret IS NOT NULL AND Ret < returns_threshold() AND Date >= startDate()
  )
  // Calculate uniform allocation of daily $100k for each day with opportunities
  unifAlloc(Date, AllocAmt) AS (
    SELECT Date, amt() / count(BuyPrice) FROM purchases GROUP BY Date
  )
  // Calculate Profits for each day
  dailyProfit(Date, PnL) AS (
    SELECT Date, sum((AllocAmt / BuyPrice) * (SellPrice - BuyPrice)) 
    FROM purchases INNER JOIN unifAlloc USING Date
    GROUP BY Date)
  // Return running profits
  SELECT Date, sums(PnL) as runningProfit from dailyProfit
  








