// Moving variance calculation for technology stocks
CREATE TABLE prices (
  Open          FLOAT,
  High          FLOAT,
  Low           FLOAT,
  Close         FLOAT,
  Volume        FLOAT,
  EndOfDayPrice FLOAT,
  ID            STRING,
  Date          DATE
)

LOAD DATA INFILE "./data/sp500_eod_complete_data.csv" INTO TABLE prices
FIELDS TERMINATED BY  ","

<q>vars:{mavg[x;y*y]-m*m:mavg[x;y:"f"$y]}</q>
// moving variance for technology stocks
WITH
  variances(Date, ID, mv) AS (
    SELECT Date, ID,
      vars(12, ratios(1, EndOfDayPrice) - 1)
      FROM prices
      ASSUMING ASC Date
      WHERE ID in ("HP", "ORCL", "YHOO")
      AND Date >= '01/01/2015'
      GROUP BY ID
  )

SELECT * FROM FLATTEN(variances)


// Correlation of returns calculation for data
<q>
\S 1
corrTickers10:neg[10]?exec distinct ID from prices
</q>

WITH
  stocksGrouped(ID, Ret) AS (
    SELECT ID, ratios(1, EndOfDayPrice) - 1
    FROM prices
    ASSUMING ASC ID, ASC Date
    WHERE ID in corrTickers10 AND
    Date >= max(Date) - 31 * 6
    GROUP BY ID)

  pairsGrouped(ID1, ID2, R1, R2) AS (
    SELECT st1.ID, st2.ID, 
    st1.Ret, st2.Ret
    FROM stocksGrouped st1, stocksGrouped st2)
  
SELECT ID1, ID2,
cor(R1, R2) as coef 
FROM FLATTEN(pairsGrouped)
WHERE ID1 != ID2
GROUP BY ID1, ID2


// Moving Average Query for a specific stock
WITH
  mavgPrices(Date, Price, m21, m5) AS (
    SELECT 
    Date, 
    EndOfDayPrice,
    avgs(21,  EndOfDayPrice),
    avgs(5,  EndOfDayPrice)
    FROM prices
    ASSUMING ASC Date
    WHERE ID="HP"
    AND Date >= '01/01/2014')

// some simple if-else clauses to generate points
// for plotting signals
SELECT Date, Price,
m21, m5, 
CASE (prev(m5) <= prev(m21) & m5 > m21) 
 WHEN TRUE THEN
   Price
 ELSE make_null(Price)
 END as BuySignal,
CASE (prev(m5) >= prev(m21) & m5 < m21) 
WHEN TRUE THEN
  Price
ELSE make_null(Price) 
END as SellSignal
FROM mavgPrices

/************************
 TRADING STRATEGIES
 ************************/


 // We can encode query parameters as functions
 FUNCTION amt() {
   100000
 }

 FUNCTION startDate() {
   '01/01/2000'
 }
 
 FUNCTION endDate() {
   '01/01/2016'
 }
 
 FUNCTION ticker() {
   "AAPL"
 }

 FUNCTION returns_threshold() {
   -0.02
 }

 FUNCTION holding_period() {
   200
 }


/* 
Perfect knowledge query
*/

WITH
  runningProfit(Date, Price, RunningMinPrice, Profit) AS (
    SELECT Date, 
    EndOfDayPrice,
    mins(EndOfDayPrice), 
    (EndOfDayPrice - mins(EndOfDayPrice)) * (amt / mins(EndOfDayPrice))
    FROM prices
    ASSUMING ASC Date
    WHERE ID = ticker()
    AND Date >= startDate() AND Date <= endDate())
  
  markedUp(Date, Price, BestBuyPrice, BestSellPrice, Profit) AS (
    SELECT 
    Date,
    Price,
    CASE 
      WHEN Profit = max(Profit)
        THEN
          RunningMinPrice
        ELSE
          make_null(RunningMinPrice)
    END as BestBuyPrice,
    CASE 
      WHEN Profit = max(Profit)
        THEN
          Price
        ELSE
          make_null(Price)
    END as BestSellPrice,
    Profit
    FROM runningProfit)
    
  SELECT
  Date,
  Price,
  CASE
    WHEN Price = max(BestBuyPrice)
      THEN
        Price
      ELSE
        make_null(Price)
  END as BestBuyPrice,
  BestSellPrice,
  Profit
  FROM markedUp
      



 
 /*
   Buy cheap strategy:
   Parameters: startDate, returns threshold, holding period (in business days), amount
   of money available for each investment date
   Investment "loop" (every trading day):
      - find set of stocks S with period returns < threshold (underperformers)
      if S not empty:
        - invest amount uniformly amongst them (we have access to M at each opportunity)
        - at end of y days, sell entire position (we always clear out, ie. each investment
        date is a "new portfolio")
   Display profit/loss associated with each investment date (when bought)
 */
 



WITH
  // calculate returns over period and sell price by shifting back future prices
  returns(Date, ID, BuyPrice, SellPrice, Ret) AS (
    SELECT Date, ID, EndOfDayPrice, 
    next(holding_period(), EndOfDayPrice), ratios(holding_period(), EndOfDayPrice)-1
    FROM prices ASSUMING ASC Date 
    GROUP BY ID
  )
  // select those underperformers that we are interested in
  purchases(Date, ID, BuyPrice, SellPrice, Ret) AS (
    SELECT * FROM FLATTEN(returns) WHERE Ret IS NOT NULL AND Ret < returns_threshold() AND Date >= startDate()
  )
  // Calculate uniform allocation of daily $100k for each day with opportunities
  unifAlloc(Date, AllocAmt) AS (
    SELECT Date, amt() / count(BuyPrice) FROM purchases GROUP BY Date
  )
  // Calculate Profits for each day
  dailyProfit(Date, PnL) AS (
    SELECT Date, sum((AllocAmt / BuyPrice) * (SellPrice - BuyPrice)) 
    FROM purchases INNER JOIN unifAlloc USING Date
    GROUP BY Date)
  // Return running profits
  SELECT Date, sums(PnL) as runningProfit from dailyProfit
  

/*
  Technical trading:
  Parameters: date range, amount of money for each bet, length of 2 moving averages
  (one shorter than other), ticker
  For a given ticker, find places where moving averages cross within date range,
  each time that short term signal crosses above: buy, below: sell
  In each buy we use entire amount (i.e. amount is per buy opportunity),
  and we always close out at each sell date. The profits are reported 
  for the given buy date.
*/

FUNCTION short_window() {
  5
}

FUNCTION long_window() {
  21
}


WITH
  // calculate moving averages
  mavgPrices(Date, Price, long_avg, short_avg) AS (
    SELECT 
    Date, 
    EndOfDayPrice,
    avgs(long_window(),  EndOfDayPrice),
    avgs(short_window(),  EndOfDayPrice)
    FROM prices
    ASSUMING ASC Date
    WHERE ID = ticker()
    AND Date >= startDate() - long_window()
    AND Date <= endDate())
  
  // find relevant observations (buy/sell points) iin appropriate date range
  crosspoints(Date, Price, BuySignal, valid) AS (
  SELECT Date, 
  Price,
  (prev(short_avg) <= prev(long_avg) & short_avg > long_avg),
  maxs((prev(short_avg) <= prev(long_avg) & short_avg > long_avg))
  FROM mavgPrices
  WHERE
  ((prev(short_avg) <= prev(long_avg) & short_avg > long_avg) OR
  (prev(short_avg) >= prev(long_avg) & short_avg < long_avg)) AND
  Date >= startDate() AND Date <= endDate())
  
  // Need to have bought before sold, buy/sell always alternate by definition
  // so for buying points the PotentialProfit is the actual profit for that trade
  profits(Date, Signal, RunningProfit) AS (
  SELECT Date,
  CASE 
    WHEN BuySignal
    THEN "Buy"
    ELSE "Sell"
  END,
  sums((amt() / Price) * (next(1, Price) - Price) * BuySignal)
  FROM crosspoints where valid)
    
  SELECT Date, Price, Signal, fills(RunningProfit) as runningProfit
  FROM 
  mavgPrices FULL OUTER JOIN profits USING Date
  ASSUMING ASC Date
  WHERE Date >= startDate()
  
  
  
  
  
  
  

  
  





