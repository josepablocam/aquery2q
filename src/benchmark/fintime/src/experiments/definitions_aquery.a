// Loading in data and tables using verbatim q
<q>
\l load_data.q
getMonth:{1 + (`month$x) mod 12}
getYear:{`year$x}
firstDateOfYear:{`date$`month$d-30*-1+getMonth d:`date$`month$x}
getWeek:{1 + floor (x - firstDateOfYear x)%7}
</q>



/*
********* QUERY 0 ****************
Get the closing price of a set of 10 stocks for a 10-year period and group into weekly, monthly and
yearly aggregates. For each aggregate period determine the low, high and average closing price
value. The output should be sorted by id and trade date.
*/

WITH
 // our main source of information, localized, avoiding rerunning for each aggregation
 Target(Id, TradeDate, ClosePrice)  AS (select 
 Id, TradeDate,ClosePrice
 FROM price
 where Id in stock10 and TradeDate >= startYear10 and TradeDate < startYear10 + 365 * 10)

  weekly(Id, bucket, name, low, high, mean) AS (select 
    Id,
    timeBucket,
    "weekly",
    min(ClosePrice), 
	  max(ClosePrice), avg(ClosePrice)
  	from Target group by Id, getWeek(TradeDate) as timeBucket)
	
  monthly(Id, bucket, name, low, high, mean) AS (select
    Id,
    timeBucket,
    "monthly",
     min(ClosePrice), 
	   max(ClosePrice), 
     avg(ClosePrice)
  	 from Target group by Id, getMonth(TradeDate) as timeBucket)
	
  yearly(Id, bucket, name, low, high, mean) AS (select
    Id,
    timeBucket,
    "yearly",
     min(ClosePrice), 
	   max(ClosePrice), 
     avg(ClosePrice)
  	 from Target group by Id, getYear(TradeDate) as timeBucket)
		
select Id, bucket, name, low, high, mean from CONCATENATE(weekly, monthly, yearly) 
    assuming asc Id, asc name, asc bucket


/*
********* QUERY 1 ****************
Adjust all prices and volumes (prices are multiplied by the split factor and volumes are divided by
the split factor) for a set of 1000 stocks to reflect the split events during a specified 300 day
period, assuming that events occur before the first trade of the split date. These are called
split-adjusted prices and volumes.
*/

WITH
  pxdata(Id, TradeDate, HighPrice, LowPrice, ClosePrice, OpenPrice, Volume) AS 
    (select Id, TradeDate, HighPrice, LowPrice, 
      ClosePrice, OpenPrice, Volume
      from price where Id in stock1000 and TradeDate >= start300Days 
      and TradeDate < start300Days + 300)
   
  splitdata(Id, SplitDate, SplitFactor) AS 
    (select Id, SplitDate, SplitFactor 
      from split where Id in stock1000 and SplitDate >= start300Days)

  adjdata(Id, TradeDate, AdjFactor) AS (
  select Id, TradeDate, prd(SplitFactor)
  from
  pxdata INNER JOIN splitdata USING Id 
  where TradeDate < SplitDate
  group by Id, TradeDate
  )
  
  select Id, TradeDate, HighPrice * fill(1, AdjFactor) as HighPrice,
  LowPrice * fill(1, AdjFactor) as LowPrice,
  ClosePrice * fill(1, AdjFactor) as ClosePrice,
  OpenPrice * fill(1, AdjFactor) as OpenPrice,
  Volume / fill(1, AdjFactor) as Volume
  FROM
  pxdata FULL OUTER JOIN adjdata USING (Id, TradeDate)
  ASSUMING ASC Id, ASC TradeDate


/*
********* QUERY 2 ****************
For each stock in a specified list of 1000 stocks, find the differences between the daily high and
daily low on the day of each split event during a specified period.
*/

WITH
 pxdata(Id, TradeDate, HighPrice, LowPrice) AS
   (select Id, TradeDate, HighPrice, LowPrice 
    from price where Id in stock1000 and
    TradeDate between startPeriod and endPeriod)
   
 splitdata(Id, TradeDate, SplitFactor) AS 
   (select Id, SplitDate, SplitFactor 
    from split where Id in stock1000 and 
    SplitDate between startPeriod and endPeriod)
 
 select Id as Id, TradeDate as TradeDate, HighPrice - LowPrice as MaxDiff from
 pxdata INNER JOIN splitdata USING (Id, TradeDate) assuming asc Id, asc TradeDate

 




/*
********* QUERY 3 + 4 ****************
Calculate the value of the S&P500 and Russell 2000 index for a specified day using unadjusted prices
and the index composition of the 2 indexes (see appendix for spec) on the specified day
*/
// SP 500
select avg(ClosePrice) as avg_close_price from price where Id in SP500 and TradeDate = startPeriod

// russell 2000
select avg(ClosePrice) as avg_close_price from price where Id in Russell2000 and TradeDate = startPeriod



/*
********* QUERY 5 ****************
Find the 21-day and 5-day moving average price for a specified list of 1000 stocks during a 6-month
period. (Use split adjusted prices)
*/
CREATE TABLE query5TableAQ AS
  WITH
    // Price data for the period
   pxdata(Id, TradeDate, ClosePrice) AS
     (select Id, TradeDate, ClosePrice from price 
     where Id in stock1000 and TradeDate >= start6Mo and TradeDate < start6Mo + 31 * 6)
 
   // splits that happened  
   splitdata(Id, SplitDate, SplitFactor) AS 
   (select Id, SplitDate, SplitFactor from split
     where Id in stock1000 and SplitDate >= start6Mo)
  
   // prices after adjusting for splits
   splitadj(Id, TradeDate, ClosePrice) AS
     (select Id, TradeDate, first(ClosePrice * prd(SplitFactor))
      from 
      pxdata INNER JOIN splitdata USING Id where TradeDate < SplitDate
      group by Id, TradeDate)
      
   // fill in missing splitadj price with original price when necessary
   avgInfo(Id, TradeDate, ClosePrice, m21, m5) AS 
   (select 
     Id, TradeDate, 
     fill(pxdata.ClosePrice, splitadj.ClosePrice), 
     avgs(21,  fill(pxdata.ClosePrice, splitadj.ClosePrice)),
   	  avgs(5,  fill(pxdata.ClosePrice, splitadj.ClosePrice))
   FROM pxdata FULL OUTER JOIN splitadj USING (Id, TradeDate)
   assuming asc Id, asc TradeDate
   group by Id
   )
   
  select * from FLATTEN(avgInfo) assuming asc Id, asc TradeDate
   


/*
********* QUERY 6 ****************
(Based on the previous query) 
Find the points (specific days) when the 5-month moving average intersects the 21-day moving average
for these stocks. The output is to be sorted by id and date.
*/
select Id, TradeDate as CrossDate, ClosePrice
from query5TableAQ
where Id = prev(Id) and 
// cross over
(prev(m5) <= prev(m21) & m5 > m21)  
or 
// cross under
(prev(m5) >= prev(m21) & m5 < m21)


/*
********* QUERY 7 ****************
  Determine the value of $100,000 now if 1 year ago it was invested equally in 10 specified
   stocks (i.e. allocation for each stock is $10,000). The trading strategy is: 
   When the 20-day moving average crosses over the 5-month moving average 
   the complete allocation for that stock is invested and when the 
   20-day moving average crosses below the 5-month moving average the 
   entire position is sold. The trades happen on the closing price of the trading day.
*/
// encode execution of our trading strategy
FUNCTION executeStrategy(alloc, mavgday, mavgmonth, px) {
  buySignal := mavgday > mavgmonth;
  alloc * prd(
        CASE maxs(buySignal)
          WHEN TRUE THEN
            CASE buySignal
              WHEN TRUE THEN 1 / px // how much can we buy
              ELSE px // how much can we sell for
            END
          ELSE 1 // we cannot sell before we've bought, so just sit on 10k
        END)
}

WITH
  relevant AS (
  select Id, TradeDate, ClosePrice from price  
    where Id in stock10 and TradeDate >= max(TradeDate) - 365 
  )
  // moving averages for each of the stocks
  movingAverages AS (
    select Id, TradeDate, ClosePrice, avgs(20, ClosePrice) as m20day,
    avgs(31 * 5, ClosePrice) as m5month from relevant assuming asc Id, asc TradeDate
    group by Id
  )
  // points of interest: when we invest all or sell all
  // execute strategy accordingly
 simulated AS (
   select Id, ClosePrice,
    executeStrategy(10000, m20day, m5month, ClosePrice) as result,
    last(m20day) > last(m5month) as stillInvested
    from FLATTEN(movingAverages)
     where Id = prev(Id) and
     // (sell)
     (prev(m5month) <= prev(m20day) & m5month > m20day)  
     or 
     // (buy)
     (prev(m5month) >= prev(m20day) & m5month < m20day)
     group by Id
     
   )
  // latest set of prices (needed for those stocks that we still hold)
  latestPxs AS (select * from relevant where TradeDate=max(TradeDate))  
  // the value of our portfolio broken up by stock
  select Id, result * CASE WHEN stillInvested THEN currpx.ClosePrice ELSE 1 END as dollars
  from simulated INNER JOIN latestPxs currpx USING Id
  



/*
********* QUERY 8 ****************
Find the pair-wise coefficients of correlation in a set of 10 securities for a 2 year period. Sort 
the securities by the coefficient of correlation, indicating the pair of securities corresponding to
that row. [Note: coefficient of correlation defined in appendix]
*/
FUNCTION covariance(x, y) {
  xmean := avg(x);
  ymean := avg(y);
  avg((x - xmean) * (y - ymean))
}

FUNCTION sd(x) {
  sqrt(covariance(x, x))
}

FUNCTION pairCorr(x, y) {
  sd1 := sqrt(covariance(x, y));
  covariance(x, y) / (sd(x) * sd(y))
}

// we can leverage q directly when it suits us
// in this case, aquery has not exposed adverbs directly
// as users sometimes have a hard time grasping their use
// in this case, we allow savy users to use verbatim q
// to add an adverb to their aquery-defined function
<q>pairCorrEach:pairCorr'</q>

WITH
  stocksGrouped(Id, ClosePrice) AS (select Id, ClosePrice 
  from price assuming asc Id, asc TradeDate
  where Id in stock10 and 
  TradeDate >= startYear10 and
  TradeDate < startYear10 + 365 * 2 
  group by Id)
  
  pairsGrouped(Id1, Id2, ClosePrice1, ClosePrice2) AS (
    select st1.Id, st2.Id, st1.ClosePrice, st2.ClosePrice 
    from stocksGrouped st1, stocksGrouped st2 group by st1.Id, st2.Id)
  
  corrTable(Id1, Id2, corrCoeff) AS (select Id1, Id2,
       pairCorrEach(ClosePrice1, ClosePrice2) from
       pairsGrouped where Id1 != Id2)
  select * from corrTable assuming desc corrCoeff  
  
  
/*
********* QUERY 9 ****************
Determine the yearly dividends and annual yield (dividends/average closing price) for the past 3 
years for all the stocks in the Russell 2000 index that did not split during that period. 
Use unadjusted prices since there were no splits to adjust for.
*/
WITH
    // we introduce a dummy column to avoid having q
    // group on distinct
    splitdata(Dummy, Id) AS (
    select 1, distinct(Id) from split where Id in Russell2000 and
    SplitDate >= max(SplitDate) - 365 * 3
    )
    
    nosplit_avgpx AS (
    select Id, year, avg(ClosePrice) as avg_px from price where Id in Russell2000 and 
    TradeDate >= max(TradeDate) - 365 * 3 and Id not in splitdata("Id")
    group by Id, getYear(TradeDate) as year
    )
    
    divdata AS (
      select Id, year, sum(DivAmt) as total_divs from dividend where Id in Russell2000 and
      XdivDate >= max(XdivDate) - 365 * 3  and Id not in splitdata("Id")
      group by Id, getYear(XdivDate) as year
    )
    
    select Id, year, avg_px, total_divs, fill(0.0, total_divs) / avg_px as yield
    FROM nosplit_avgpx FULL OUTER JOIN divdata USING (Id, year)
    ASSUMING ASC Id, ASC year
    
    
  
  